# C语言进阶-数据存储

## 数据在内存中的存储-整型

### 整型

首先我们来复习一下数据类型,整型家族基本有以下几种:

![image-20231101110318183](D:\My-Repo\C\笔记\Markdown\C语言进阶-数据存储.assets\image-20231101110318183.png)


还有一个long long型,不过long基本够用,long long取值范围很大了.另外char型 字符型,其本质也是`ASCII码`值作为数字保存在计算机中,所以被归类为整型,char型的有无符号位取决于编辑器,另外三个整型一般都默认为有符号

整型的取值范围都在`limits.h`这个头文件中有定义:

![image-20231101152920481](D:\My-Repo\C\笔记\Markdown\C语言进阶-数据存储.assets\image-20231101152920481.png)


### 源码,反码与补码

整型以二进制存到内存中时有三种状态:

1.  `源码`	
2.  `反码`
3.  `补码` 

```c
//源码的第一位为符号位(0正1负)

//=================================================

//正数的源反补码均相同
int num = 9;
//那么变量num在内存中就应该是这样的
//00000000000000000000000000001001	源码(首数字为0,其余位用二进制表示)/反码/补码

//由于用二进制表示会比较长,所以我们会将2进制转为16进制表示(4个2进制数为一个16进制数,两两一对)即:
//0000 0000 0000 0000 0000 0000 0000 1001
//  0    0    0    0    0    0    0    9
//00 00 00 09

//=================================================

//负数有一定的规则
//源码:	首数字为1,其余位用二进制表示
//反码:	在源码的基础上符号位不变,其余位取反
//补码:	在反码的基础上+1
int num2 = -14
    
//10000000000000000000000000001110	源码
//11111111111111111111111111110001	反码
//11111111111111111111111111110010	补码
    
//1111 1111 1111 1111 1111 1111 1111 0010
//  f	 f	  f    f    f    f    f    2
//ff ff ff f2
```

可以用编译器试验一下:

![image-20231101143316331](D:\My-Repo\C\笔记\Markdown\C语言进阶-数据存储.assets\image-20231101143316331.png)num 补码:00 00 00 09![image-20231101143518838](D:\My-Repo\C\笔记\Markdown\C语言进阶-数据存储.assets\image-20231101143518838.png)num2 补码:ff ff ff f2
不难看出与我们推算的有一些出入,这是什么情况怎么与我们分析的数字相反了?

### 字节序

这其实是因为VS编译器的存储数据是小端存储模式导致的.那么什么是小端存储,又为什么要有这种存储模式呢?

>   大端（存储）模式：是指数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处。

>   小端（存储）模式：是指数据的低位字节内容保存在内存的低地址处，而数据的高位字节内容，保存在内存的高地址处

因为拥有多种数据类型,而每个关键字都需要不同的大小空间,于是为了统一存放的标准,也就有了大小端的存储模式

```c
//例如还是上面的num = 9在内存的补码
//00 00 00 09
//右边为高位,左边为低位

//大端(高放低,低放高)
//把原来的高位放入低位,低位放到高位(其实就是互换)
//09 00 00 00 

//小端(低放低,高放高)
//说白了没变,是什么样就放什么样
//00 00 00 09

//这就是大小端的两种方式
```

## 数据在内存中的存储-浮点型

### 浮点型

知道的人肯定知道,我们C语言中的浮点型无非就两种(其实还有个long double):
![image-20231101151511787](D:\My-Repo\C\笔记\Markdown\C语言进阶-数据存储.assets\image-20231101151511787.png)

浮点型的存储方式又与整型不大一样,浮点型的存储方式是出自国际标准`IEEE`(电气和电子工程协会)`754`，任意二进制浮点数V可以用以下公式表示:
$$
V = (−1)^S ∗M ∗ 2^E
$$

-   (-1)^S^表示符号位,当S = 0 时,说明V是一个正数,反之当S = 1时,浮点数V为负数
-   M表示有效位
-   2^E^表示指数位

```c
//下面举几个例子加深一下印象

//例如: 十进制的9.0转换成二进制
// 1001.0	相当于1.001 * 2^3
//由上面的结论可知S = 0,M = 1.001,E = 3

//相反如果是十进制-9.0转换为二进制
// -1001.0 相当于 -1.001 * 2^3
//S = 1,M = 1.001,E = 3

//这里要注意
//如果
```

对于如何存入float型和double型的数也有规定:
如float为4byte也就是32bit,拥有32个位.与整型一样第一位是符号位,`第1位存符号位S,后面8位(即2-9位)存指数位E接着剩下的23位存有效位M.`

double也是差不多:`第1位存符号位S,后面11位(即2-12位)存指数位E接着剩下的52位存有效位M.`

float
![image-20231101163501550](D:\My-Repo\C\笔记\Markdown\C语言进阶-数据存储.assets\image-20231101163501550.png)

double
![image-20231101163821267](D:\My-Repo\C\笔记\Markdown\C语言进阶-数据存储.assets\image-20231101163821267.png)

另外在存有效位时,1<= M < 2的,所以小数点前总是1,于是乎IEEE 745中规定保存有效位时只保存小数点后面的数如存1.11,M中只写11


学会了存,那我们在学一下怎么取:

浮点数往外取,分别有三种情况

1.  